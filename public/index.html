<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FBX to VRMA Converter</title>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/",
            "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@2.1.0/lib/three-vrm.module.js"
        }
    }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 40px;
            max-width: 1200px;
            width: 90%;
            display: flex;
            gap: 40px;
        }

        .left-panel {
            flex: 1;
            min-width: 500px;
        }

        .right-panel {
            flex: 1;
            min-width: 500px;
        }

        .vrm-viewer {
            width: 100%;
            height: 500px;
            border: 2px solid #ddd;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }

        .viewer-controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .control-btn {
            padding: 8px 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .control-btn:hover {
            background: #5a68c7;
        }

        @media (max-width: 1024px) {
            .container {
                flex-direction: column;
                max-width: 600px;
            }
            
            .left-panel, .right-panel {
                min-width: auto;
            }
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #333;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 1.1rem;
        }

        .upload-area {
            border: 3px dashed #ddd;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin: 30px 0;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #667eea;
            background-color: #f8f9ff;
        }

        .upload-area.dragover {
            border-color: #667eea;
            background-color: #f0f4ff;
        }

        .upload-icon {
            font-size: 3rem;
            color: #ddd;
            margin-bottom: 20px;
        }

        .upload-text {
            color: #666;
            font-size: 1.1rem;
            margin-bottom: 10px;
        }

        .file-input {
            display: none;
        }

        .settings {
            margin: 20px 0;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 5px;
            color: #333;
            font-weight: 500;
        }

        .setting-group input, .setting-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .setting-group input:focus, .setting-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .convert-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease;
            margin-top: 20px;
        }

        .convert-btn:hover {
            transform: translateY(-2px);
        }

        .convert-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .progress {
            display: none;
            margin: 20px 0;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #eee;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 4px;
            transition: width 0.3s ease;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .result {
            display: none;
            margin-top: 20px;
            padding: 20px;
            background: #f0f8ff;
            border-radius: 10px;
            text-align: center;
        }

        .result.success {
            background: #f0fff0;
            border: 2px solid #4caf50;
        }

        .result.error {
            background: #fff0f0;
            border: 2px solid #f44336;
        }

        .download-btn {
            display: inline-block;
            margin-top: 15px;
            padding: 12px 24px;
            background: #4caf50;
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: background 0.3s ease;
        }

        .download-btn:hover {
            background: #45a049;
        }

        .file-info {
            display: none;
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .warning strong {
            display: block;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="left-panel">
            <div class="header">
                <h1>üé≠ FBX to VRMA</h1>
                <p>Mixamo„ÅÆFBX„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÇíVRMAÂΩ¢Âºè„Å´Â§âÊèõ</p>
            </div>

            <div class="warning">
                <strong>‚ö†Ô∏è Ê≥®ÊÑè‰∫ãÈ†Ö</strong>
                ‰ΩúÊàê„Åï„Çå„ÇãVRMA„Éï„Ç°„Ç§„É´„ÅØVRoid Studio„Åß„ÅØÂÜçÁîü„Åß„Åç„Åæ„Åõ„Çì„ÄÇThree.js VRM„Åß„ÅÆ‰ΩøÁî®„ÇíÂâçÊèê„Å®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ
            </div>

            <form id="converterForm" enctype="multipart/form-data">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">üìÅ</div>
                <div class="upload-text">FBX„Éï„Ç°„Ç§„É´„Çí„Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„Éó</div>
                <div style="color: #999; font-size: 0.9rem;">„Åæ„Åü„ÅØ „ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû</div>
                <input type="file" id="fbxFile" name="fbxFile" class="file-input" accept=".fbx" required>
            </div>

            <div class="file-info" id="fileInfo">
                <strong>ÈÅ∏Êäû„Åï„Çå„Åü„Éï„Ç°„Ç§„É´:</strong>
                <span id="fileName"></span>
                <br>
                <strong>„Çµ„Ç§„Ç∫:</strong>
                <span id="fileSize"></span>
            </div>

            <div class="settings">
                <div class="setting-group">
                    <label for="framerate">„Éï„É¨„Éº„É†„É¨„Éº„Éà (FPS)</label>
                    <input type="number" id="framerate" name="framerate" value="30" min="1" max="120" step="1">
                </div>
            </div>

            <button type="submit" class="convert-btn" id="convertBtn">
                üîÑ VRMAÂΩ¢Âºè„Å´Â§âÊèõ
            </button>
        </form>

        <div class="progress" id="progress">
            <div style="text-align: center; margin-bottom: 10px; color: #666;">
                Â§âÊèõ‰∏≠... <span id="progressText">Ê∫ñÂÇô‰∏≠</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
        </div>

        <div class="result" id="result">
            <div id="resultMessage"></div>
            <a href="#" id="downloadBtn" class="download-btn" style="display: none;">
                üì• VRMA„Éï„Ç°„Ç§„É´„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
            </a>
        </div>
        </div>

        <div class="right-panel">
            <div class="header">
                <h2>VRM„Éó„É¨„Éì„É•„Éº</h2>
                <p>„Éâ„É©„ÉÉ„Ç∞„ÅßÂõûËª¢„ÄÅ„Éû„Ç¶„Çπ„Éõ„Ç§„Éº„É´„Åß„Ç∫„Éº„É†</p>
            </div>
            
            <canvas id="vrmCanvas" class="vrm-viewer"></canvas>
            
            <div class="viewer-controls">
                <button class="control-btn" onclick="resetCamera()">‰ΩçÁΩÆ„É™„Çª„ÉÉ„Éà</button>
                <button class="control-btn" onclick="toggleAnimation()">„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂÅúÊ≠¢</button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { VRMLoaderPlugin } from '@pixiv/three-vrm';
        import { loadVRMAnimation } from './lib/VRMAnimation/loadVRMAnimation.js';

        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fbxFile');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const converterForm = document.getElementById('converterForm');
        const convertBtn = document.getElementById('convertBtn');
        const progress = document.getElementById('progress');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const result = document.getElementById('result');
        const resultMessage = document.getElementById('resultMessage');
        const downloadBtn = document.getElementById('downloadBtn');

        // File upload handling
        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', handleDragOver);
        uploadArea.addEventListener('dragleave', handleDragLeave);
        uploadArea.addEventListener('drop', handleDrop);
        fileInput.addEventListener('change', handleFileSelect);

        function handleDragOver(e) {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                fileInput.files = files;
                handleFileSelect();
            }
        }

        function handleFileSelect() {
            const file = fileInput.files[0];
            if (file) {
                fileName.textContent = file.name;
                fileSize.textContent = formatFileSize(file.size);
                fileInfo.style.display = 'block';
                uploadArea.style.borderColor = '#4caf50';
                uploadArea.querySelector('.upload-text').textContent = '‚úÖ „Éï„Ç°„Ç§„É´„ÅåÈÅ∏Êäû„Åï„Çå„Åæ„Åó„Åü';
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Form submission
        converterForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            if (!fileInput.files[0]) {
                alert('FBX„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                return;
            }

            const formData = new FormData();
            formData.append('fbxFile', fileInput.files[0]);
            formData.append('framerate', document.getElementById('framerate').value);

            // Show progress
            convertBtn.disabled = true;
            convertBtn.textContent = 'Â§âÊèõ‰∏≠...';
            progress.style.display = 'block';
            result.style.display = 'none';

            // Simulate progress
            simulateProgress();

            try {
                const response = await fetch('/convert', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (data.success) {
                    showResult('success', '‚úÖ Â§âÊèõ„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„ÅüÔºÅ', data.downloadUrl, data.filename, data.directUrl);
                } else {
                    showResult('error', `‚ùå Â§âÊèõ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ${data.error}`);
                }
            } catch (error) {
                showResult('error', `‚ùå „Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ${error.message}`);
            } finally {
                convertBtn.disabled = false;
                convertBtn.textContent = 'üîÑ VRMAÂΩ¢Âºè„Å´Â§âÊèõ';
                progress.style.display = 'none';
            }
        });

        function simulateProgress() {
            const stages = [
                { text: 'FBX„Éï„Ç°„Ç§„É´„ÇíËß£Êûê‰∏≠...', progress: 20 },
                { text: 'GLTF„Å´Â§âÊèõ‰∏≠...', progress: 50 },
                { text: 'VRMA„Éá„Éº„Çø„ÇíÁîüÊàê‰∏≠...', progress: 80 },
                { text: 'ÊúÄÁµÇÂá¶ÁêÜ‰∏≠...', progress: 95 }
            ];

            let currentStage = 0;
            const interval = setInterval(() => {
                if (currentStage < stages.length) {
                    const stage = stages[currentStage];
                    progressText.textContent = stage.text;
                    progressFill.style.width = stage.progress + '%';
                    currentStage++;
                } else {
                    clearInterval(interval);
                }
            }, 1500);
        }

        async function showResult(type, message, downloadUrl = null, filename = null, directUrl = null) {
            result.className = `result ${type}`;
            result.style.display = 'block';
            resultMessage.textContent = message;

            if (downloadUrl && filename) {
                downloadBtn.href = downloadUrl;
                downloadBtn.download = filename;
                downloadBtn.style.display = 'inline-block';
                
                // Auto-load VRMA animation if conversion was successful
                if (type === 'success' && filename.endsWith('.vrma') && directUrl) {
                    try {
                        console.log('Auto-loading VRMA animation:', directUrl);
                        const animationName = filename.replace('.vrma', '');
                        const action = await loadAndPlayVRMAAnimation(directUrl, animationName);
                        
                        if (action) {
                            // Play the animation with a slight delay to ensure smooth loading
                            setTimeout(() => {
                                playVRMAAnimation(animationName, true);
                                resultMessage.textContent = message + ' „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÅåËá™ÂãïÂÜçÁîü„Åï„Çå„Åæ„Åó„ÅüÔºÅ';
                                // „Éú„Çø„É≥„ÅÆÂàùÊúüÊõ¥Êñ∞„ÇíÁ¢∫ÂÆü„Å´ÂÆüË°å
                                setTimeout(updateAnimationButton, 100);
                            }, 500);
                        }
                    } catch (error) {
                        console.error('Failed to auto-load VRMA animation:', error);
                        resultMessage.textContent = message + ' („Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Ëá™ÂãïË™≠„ÅøËæº„Åø„Å´Â§±Êïó)';
                    }
                }
            } else {
                downloadBtn.style.display = 'none';
            }
        }

        // VRM Viewer Setup with VRMA animation support
        let scene, camera, renderer, vrm, mixer, clock;
        let isMouseDown = false;
        let mouseX = 0, mouseY = 0;
        let modelRotationY = Math.PI; // ÂàùÊúüÂÄ§„Çí180Â∫¶ÔºàœÄÔºâ„Å´Ë®≠ÂÆö
        let modelRotationX = 0; // XËª∏ÂõûËª¢Ôºà‰∏ä‰∏ãÔºâ„ÇíËøΩÂä†
        let cameraDistance = 1.5; // „Ç´„É°„É©„ÅÆË∑ùÈõ¢„ÇíÂ∞ë„ÅóËøë„Åè
        const minDistance = 0.5;
        const maxDistance = 10;
        let modelGroup; // VRM„É¢„Éá„É´„ÇíÂåÖÂê´„Åô„Çã„Ç∞„É´„Éº„Éó
        let currentAnimationAction = null; // ÁèæÂú®ÂÜçÁîü‰∏≠„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
        let animationActions = new Map(); // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆÁÆ°ÁêÜ
        let lastAnimationName = null; // Áõ¥Ëøë„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Âêç
        let isAnimationPlaying = false; // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂÜçÁîüÁä∂ÊÖã

        async function initVRMViewer() {
            const canvas = document.getElementById('vrmCanvas');
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            updateCameraPosition();
            camera.lookAt(0, 1, 0); // „Ç´„É°„É©„ÇíÈÅ©Âàá„Å™È´ò„Åï„Å´Âêë„Åë„Çã
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Lighting - brighter setup
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Add fill light from the opposite side
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.6);
            fillLight.position.set(-1, 0.5, -1);
            scene.add(fillLight);
            
            // Clock for animations
            clock = new THREE.Clock();
            
            // Load VRM model (basic loading without VRMA support)
            try {
                const loader = new GLTFLoader();
                loader.register((parser) => {
                    return new VRMLoaderPlugin(parser);
                });
                
                console.log('Loading VRM model...');
                const gltf = await loader.loadAsync('/nikechan_v2.vrm');
                console.log('GLTF loaded:', gltf);
                vrm = gltf.userData.vrm;
                
                if (vrm) {
                    // Create a group to hold the VRM model for proper rotation
                    modelGroup = new THREE.Group();
                    modelGroup.add(vrm.scene);
                    scene.add(modelGroup);
                    
                    // Position the model at center
                    vrm.scene.position.set(0, 0, 0);
                    
                    // Set the pivot point of the group to abdomen height
                    modelGroup.position.set(0, 0, 0);
                } else {
                    throw new Error('VRM data not found in loaded file');
                }
                
                // Initialize animation mixer for VRMA animations
                mixer = new THREE.AnimationMixer(vrm.scene);
                
                // Handle built-in animations if any
                if (gltf.animations && gltf.animations.length > 0) {
                    gltf.animations.forEach(clip => {
                        const action = mixer.clipAction(clip);
                        animationActions.set(clip.name || 'builtin', action);
                    });
                }
                
                console.log('VRM model loaded successfully');
            } catch (error) {
                console.error('Failed to load VRM model:', error);
                // Show error in viewer
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const cube = new THREE.Mesh(geometry, material);
                scene.add(cube);
            }
            
            // Mouse controls for rotation
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mouseleave', onMouseUp);
            
            // Touch controls for mobile
            canvas.addEventListener('touchstart', onTouchStart);
            canvas.addEventListener('touchmove', onTouchMove);
            canvas.addEventListener('touchend', onTouchEnd);
            
            // Wheel controls for zoom
            canvas.addEventListener('wheel', onWheel);
            
            // Start render loop
            animate();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            
            // Update VRM
            if (vrm) {
                vrm.update(deltaTime);
            }
            
            // Update animations
            if (mixer) {
                mixer.update(deltaTime);
            }
            
            // Apply model rotation around its center (abdomen area)
            if (modelGroup) {
                // Set the pivot point for rotation (abdomen height)
                const pivotY = 0.8;
                
                // Position VRM model to rotate around abdomen
                vrm.scene.position.set(0, -pivotY, 0);
                
                // Apply rotations to the group
                modelGroup.rotation.x = modelRotationX;
                modelGroup.rotation.y = modelRotationY;
                
                // Position the group to center the model properly
                modelGroup.position.set(0, pivotY, 0);
            }
            
            renderer.render(scene, camera);
        }
        
        // Mouse control functions
        function onMouseDown(event) {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }
        
        function onMouseMove(event) {
            if (!isMouseDown) return;
            
            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;
            
            modelRotationY += deltaX * 0.01;
            modelRotationX += deltaY * 0.01;
            
            // Limit X rotation to prevent over-rotation
            modelRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, modelRotationX));
            
            mouseX = event.clientX;
            mouseY = event.clientY;
        }
        
        function onMouseUp(event) {
            isMouseDown = false;
        }
        
        // Camera position update function
        function updateCameraPosition() {
            camera.position.set(0, 1.4, cameraDistance);
        }
        
        // Wheel control function
        function onWheel(event) {
            event.preventDefault();
            
            const delta = event.deltaY > 0 ? 0.2 : -0.2;
            cameraDistance = Math.max(minDistance, Math.min(maxDistance, cameraDistance + delta));
            
            updateCameraPosition();
        }
        
        // Touch control functions
        function onTouchStart(event) {
            event.preventDefault();
            if (event.touches.length === 1) {
                isMouseDown = true;
                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
            }
        }
        
        function onTouchMove(event) {
            event.preventDefault();
            if (!isMouseDown || event.touches.length !== 1) return;
            
            const deltaX = event.touches[0].clientX - mouseX;
            const deltaY = event.touches[0].clientY - mouseY;
            
            modelRotationY += deltaX * 0.01;
            modelRotationX += deltaY * 0.01;
            
            // Limit X rotation to prevent over-rotation
            modelRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, modelRotationX));
            
            mouseX = event.touches[0].clientX;
            mouseY = event.touches[0].clientY;
        }
        
        function onTouchEnd(event) {
            event.preventDefault();
            isMouseDown = false;
        }
        
        // Control functions - make them global
        window.resetCamera = function() {
            cameraDistance = 1.5;
            updateCameraPosition();
            camera.lookAt(0, 1, 0);
            modelRotationY = Math.PI; // ÂàùÊúüÁä∂ÊÖã„ÅÆ180Â∫¶ÂõûËª¢„Å´Êàª„Åô
            modelRotationX = 0; // XËª∏ÂõûËª¢„ÇÇ„É™„Çª„ÉÉ„Éà
        }
        
        // VRMA Animation functions
        async function loadAndPlayVRMAAnimation(url, animationName = 'vrma_animation') {
            if (!vrm || !mixer) {
                console.warn('VRM model not loaded. Cannot load VRMA animation.');
                return false;
            }
            
            try {
                console.log('Loading VRMA animation from:', url);
                const vrmAnimation = await loadVRMAnimation(url);
                
                if (vrmAnimation) {
                    // Create animation clip from VRMA
                    const clip = vrmAnimation.createAnimationClip(vrm);
                    const action = mixer.clipAction(clip);
                    
                    // Store the action
                    animationActions.set(animationName, action);
                    
                    console.log(`VRMA animation '${animationName}' loaded successfully`);
                    return action;
                } else {
                    console.error('Failed to load VRMA animation');
                    return false;
                }
            } catch (error) {
                console.error('Error loading VRMA animation:', error);
                return false;
            }
        }
        
        function playVRMAAnimation(animationName, loop = true) {
            const action = animationActions.get(animationName);
            if (!action) {
                console.warn(`Animation '${animationName}' not found`);
                return;
            }
            
            // Stop current animation
            if (currentAnimationAction) {
                currentAnimationAction.stop();
            }
            
            // Play new animation
            action.reset();
            action.loop = loop ? THREE.LoopRepeat : THREE.LoopOnce;
            action.play();
            currentAnimationAction = action;
            lastAnimationName = animationName; // Áõ¥Ëøë„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Âêç„Çí‰øùÂ≠ò
            isAnimationPlaying = true;
            updateAnimationButton(); // „Éú„Çø„É≥„ÉÜ„Ç≠„Çπ„Éà„ÇíÊõ¥Êñ∞
            
            console.log(`Playing animation: ${animationName} (loop: ${loop})`);
        }
        
        function toggleAnimation() {
            if (isAnimationPlaying) {
                // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂÅúÊ≠¢
                if (currentAnimationAction) {
                    currentAnimationAction.stop();
                    currentAnimationAction = null;
                    isAnimationPlaying = false;
                    updateAnimationButton();
                    console.log('Animation stopped');
                }
            } else {
                // Áõ¥Ëøë„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÇíÂÜçÁîü
                if (lastAnimationName && animationActions.has(lastAnimationName)) {
                    playVRMAAnimation(lastAnimationName, true);
                    console.log('Animation resumed');
                } else {
                    console.warn('No recent animation to play');
                }
            }
        }
        
        function updateAnimationButton() {
            const button = document.querySelector('button[onclick*="stopCurrentAnimation"], button[onclick*="toggleAnimation"]');
            if (button) {
                if (isAnimationPlaying) {
                    button.textContent = '„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂÅúÊ≠¢';
                    button.onclick = toggleAnimation;
                } else if (lastAnimationName) {
                    button.textContent = '„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂÜçÁîü';
                    button.onclick = toggleAnimation;
                } else {
                    button.textContent = '„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂÅúÊ≠¢';
                    button.onclick = toggleAnimation;
                }
            }
        }
        
        // Make animation functions global
        window.loadAndPlayVRMAAnimation = loadAndPlayVRMAAnimation;
        window.playVRMAAnimation = playVRMAAnimation;
        window.toggleAnimation = toggleAnimation;
        window.updateAnimationButton = updateAnimationButton;
        
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const canvas = document.getElementById('vrmCanvas');
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        });
        
        // Initialize VRM viewer when page loads
        window.addEventListener('load', initVRMViewer);
    </script>
</body>
</html>